<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=author content="Rohan Jain"><meta name=description content="Cross Compiling Rust Binaries with Github Actions | Rohan's Personal Web Blog."><meta property="og:title" content="Cross Compiling Rust Binaries with Github Actions"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-06-27T16:50:00+05:30"><meta property="article:modified_time" content="2021-06-27T16:50:00+05:30"><title>Cross Compiling Rust Binaries with Github Actions</title><link rel=canonical href=/cargo-cross/><link rel=stylesheet href=/css/main.min.97ffe0e39b9819392033e2635f05ec47c705d94936b7483bb66889dbf15d7a90.css><link rel="shortcut icon" href=/img/favicon.ico></head><body lang=en><header><a href=/>The Perpetual Amature</a><nav><ul><li><a href=/>Home</a></li><li><a href=/about/>About</a></li></ul></nav></header><main><article><header><h1>Cross Compiling Rust Binaries with Github Actions</h1><small><time datetime=2021-06-27 title='Sun Jun 27 2021 16:50:00 +0530'>Jun 27, 2021</time>
| 4 minutes read</small></header><p>Compiling <em>rust</em> is slow, specially on low power devices such as a
<em>Raspberry Pi</em>. I build all my rust utilities with my RPi 4 and sync to
the rest with <a href=https://syncthing.net/>syncthing</a>. That was true for
my project, <a href=https://github.com/crodjer/sysit><strong>sysit</strong></a>, as well. I
use sysit on all my systems to keep tabs on the resource usage.</p><p>Inspired from how <a href=https://github.com/lotabout/skim/blob/master/.github/workflows/publish-github.yml>skim</a>
utilizes cross compilation to build binaries directly using Github
workflows, I incorporated a similar flow in sysit.</p><h2 id=the-github-workflow><a class=heading-anchor href=#the-github-workflow aria-label="Permalink to The Github Workflow">§</a>
The Github Workflow</h2><p>The <a href=https://github.com/crodjer/sysit/blob/v0.4.0/.github/workflows/release.yml#L39>workflow</a>
to publish binaries does the following:</p><ol><li>Install the rust toolchain.</li><li>Build a release binary.</li><li>Add the binary as a release asset.</li></ol><h3 id=install-and-build-x86-64><a class=heading-anchor href=#install-and-build-x86-64 aria-label="Permalink to Install and Build: x86-64">§</a>
Install and Build: x86-64</h3><p>Supporting <code>x86-64</code> is trivial. All you need to do is specify the OS
in the matrix:</p><pre><code class=language-yaml>strategy:
  matrix:
    include:
    - build: linux
      os: ubuntu-latest
      rust: stable
    - build: macos
      os: macos-latest
      rust: stable
</code></pre><p>And build with:</p><pre><code class=language-yaml> - name: Install Rust
   run: rustup install ${{ matrix.rust }}
 - name: Build
   run: cargo build --release
</code></pre><p>to get the binary <code>target/release/sysit</code>.</p><h3 id=install-and-build-arm-v7-and-aarch64><a class=heading-anchor href=#install-and-build-arm-v7-and-aarch64 aria-label="Permalink to Install and Build: ARM v7 and AARCH64">§</a>
Install and Build: ARM v7 and AARCH64</h3><p>Adding support for ARM targest is a more involved exercise as we
need cross compilation. This is how the matrix looks:</p><pre><code class=language-yaml> - build: arm-v7
   os: ubuntu-latest
   rust: stable
   target: armv7-unknown-linux-gnueabihf
 - build: aarch64
   os: ubuntu-latest
   rust: stable
   target: aarch64-unknown-linux-gnu
</code></pre><p>We need to add the target toolchain to the <em>Install Rust</em> step above:</p><pre><code>rustup target add ${{ matrix.target }}
</code></pre><p>and then update the <em>Build</em> step with:</p><pre><code>cargo build --release --target ${{ matrix.target }}
</code></pre><p>to get the binary <code>target/${{ matrix.target }}/release/sysit</code>.</p><h4 id=linking-issues><a class=heading-anchor href=#linking-issues aria-label="Permalink to Linking Issues">§</a>
Linking Issues</h4><p>The above should be enough for most projects. But for some, like
sysit, it fails:</p><pre><code>/usr/bin/ld: /home/runner/work/sysit/sysit/target/aarch64-unknown-linux-gnu/release/deps/sysinfo-b7d4e594f5eb3b41.sysinfo.4dsxz936-cgu.0.rcgu.o: Relocations in generic ELF (EM: 183)
/usr/bin/ld: /home/runner/work/sysit/sysit/target/aarch64-unknown-linux-gnu/release/deps/sysinfo-b7d4e594f5eb3b41.sysinfo.4dsxz936-cgu.0.rcgu.o: error adding symbols: file in wrong format
collect2: error: ld returned 1 exit status
</code></pre><p>Resolving this was tricky as I had little experience with such errors.
What I eventually found was that for <code>armv7</code> and <code>aarch64</code>, I needed
to tell cargo to use their respective linkers. For <code>armv7</code>, the linker
is <code>arm-linux-gnueabihf-gcc</code> (from package: <code>gcc-arm-linux-gnueabihf</code>)
and for <code>aarch64</code>, the linker is <code>aarch64-linux-gnu-gcc</code> (from
package: <code>gcc-aarch64-linux-gnu</code>).</p><p>We need to tell cargo to use these linkers. That can be done by
adding <code>.cargo/config</code> in the package, with the following content:</p><pre><code class=language-toml>[target.aarch64-unknown-linux-gnu]
linker = &quot;aarch64-linux-gnu-gcc&quot;

[target.armv7-unknown-linux-gnueabihf]
linker = &quot;arm-linux-gnueabihf-gcc&quot;
</code></pre><p>Coming back to our workflow, this is our matrix for the two ARM
targets:</p><pre><code class=language-yaml> - build: arm-v7
   os: ubuntu-latest
   rust: stable
   target: armv7-unknown-linux-gnueabihf
   linker: gcc-arm-linux-gnueabihf
   cross: true
 - build: aarch64
   os: ubuntu-latest
   rust: stable
   target: aarch64-unknown-linux-gnu
   linker: gcc-aarch64-linux-gnu
   cross: true
</code></pre><p>We also need to ask the workflow to install the linkers using this
additional build step, which is run only when <em>cross</em> is <em>true</em>:</p><pre><code class=language-yaml> - name: Install Linker
   if: matrix.cross
   run: |
     sudo apt update
     sudo apt install ${{ matrix.linker }}
</code></pre><p>And update the build step to use cross compilation.</p><pre><code class=language-yaml> - name: Build
   run: cargo build --release --target ${{ matrix.target }}
</code></pre><blockquote><p>When <code>RUSTFLAGS</code> is set, the linker configured in <code>.cargo/config</code>.
This may end up breaking the cross build. This issue is being
tracked by <a href=https://github.com/rust-lang/cargo/issues/7984>cargo</a>.</p></blockquote><h3 id=uploading-the-binary><a class=heading-anchor href=#uploading-the-binary aria-label="Permalink to Uploading the binary">§</a>
Uploading the binary</h3><p>The binary then can be packaged as a gzipped tarball. This is where I
borrowed from <a href=https://github.com/softprops/action-gh-release>skim</a>&rsquo;s workflow.</p><pre><code class=language-yaml>  - name: Package Artifacts
    run: |
      src=$(pwd)
      stage=
      case $RUNNER_OS in
          Linux)
              stage=$(mktemp -d)
              ;;
          macOS)
              stage=$(mktemp -d -t tmp)
              ;;
      esac
      cp target/${{ matrix.target }}/release/sysit $stage/
      cd $stage
      RELEASE_VERSION=${GITHUB_REF#refs/tags/}
      ASSET_NAME=&quot;sysit-$RELEASE_VERSION-${{ matrix.target }}.tar.gz&quot;
      ASSET_PATH=&quot;$src/$ASSET_NAME&quot;
      echo &quot;ASSET_PATH=$ASSET_PATH&quot; &gt;&gt; $GITHUB_ENV
      tar czf $ASSET_PATH *
      cd $src
</code></pre><p>In addition to the binaries, I also wanted checksum&rsquo;s so that the
released tarballs are verifiable. This can be done by adding a few
lines in the above script:</p><pre><code class=language-bash>        CHECKSUM_PATH=&quot;$ASSET_PATH.sha256&quot;
        echo &quot;CHECKSUM_PATH=$CHECKSUM_PATH&quot; &gt;&gt; $GITHUB_ENV
        case $RUNNER_OS in
            Linux)
                sha256sum $ASSET_NAME &gt; $CHECKSUM_PATH
                ;;
            macOS)
                shasum -a 256 $ASSET_NAME &gt; $CHECKSUM_PATH
                ;;
        esac
</code></pre><p>With the release assets generated, the action: <a href=https://github.com/softprops/action-gh-release>softprops/action-gh-release</a>,
makes it easy:</p><pre><code class=language-yaml> - name: Release
   uses: softprops/action-gh-release@v1
   with:
     files: |
       ${{ env.ASSET_PATH }}
       ${{ env.CHECKSUM_PATH }}
   env:
     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</code></pre><p>And that&rsquo;s it! With all this in place, you can build binaries for all of your
desired platforms and have them available for download as
<a href=https://github.com/crodjer/sysit/releases/latest>a github release</a>.</p></article></main><footer><a href=/blog>All Posts</a>
<a href=//github.com/crodjer target=_blank rel=noopener>Github</a>
<a href=//linkedin.com/in/crodjer target=_blank rel=noopener>Linkedin</a>
<a href=//twitter.com/__crodjer__ target=_blank rel=noopener>Twitter</a></footer><script data-goatcounter=https://t.rohanjain.in/count async src=/js/count.min.4e3257a9873dba863f309fe89287c9f6e962d7be1758704f13b2608e58008e5f.js></script><noscript><img src="https://t.rohanjain.in/count?p=%2fcargo-cross%2f&t=Cross%20Compiling%20Rust%20Binaries%20with%20Github%20Actions"></noscript></body></html>