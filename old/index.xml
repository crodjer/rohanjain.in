<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Old on The Perpetual Amature</title><link>/old/</link><description>Recent content in Old on The Perpetual Amature</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 31 Aug 2015 00:00:00 +0000</lastBuildDate><atom:link href="/old/index.xml" rel="self" type="application/rss+xml"/><item><title>Categorizing archives by year with Hakyll</title><link>/hakyll-years/</link><pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate><guid>/hakyll-years/</guid><description>Recently, I decided to categorize my posts under directories named by the year they were created in. For example, this post is placed at: posts/2015/hakyll-years.mkd. I decided to utilize this structure to also group how archives are listed. Inspired from Hakyll&amp;rsquo;s tag functionality I wrote my own group by years functionality. This post tries to explain that. Also, I don&amp;rsquo;t see why a similar logic cannot be used to do simple pagination.</description></item><item><title>Clean URLs with Hakyll</title><link>/hakyll-clean-urls/</link><pubDate>Sun, 30 Aug 2015 00:00:00 +0000</pubDate><guid>/hakyll-clean-urls/</guid><description>The URLs generated by Hakyll, by default also include a .html extension. I have never been a fan of this. When things in reality are driven by the Content-Type header, it is absolutely redundant.
Hakyll provides all the utilities with which we can get cleaner URLs, like this page&amp;rsquo;s. For this, I rely on the fact that most of the web servers automatically serve /foo/index.html for the URL /foo/. To generate clean paths, I define a custom route - cleanRoute:</description></item><item><title>Sitemap with Hakyll</title><link>/hakyll-sitemap/</link><pubDate>Sun, 30 Aug 2015 00:00:00 +0000</pubDate><guid>/hakyll-sitemap/</guid><description>Its fairly trivial to configure Hakyll to generate sitemaps. Sitemaps helps search engines websites. Similar to any typical html page, create a template - templates/sitemap.xml:
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;urlset xmlns=&amp;#34;http://www.sitemaps.org/schemas/sitemap/0.9&amp;#34;&amp;gt; $for(entries)$ &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;$host$$url$&amp;lt;/loc&amp;gt; &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt; $if(lastmod)$&amp;lt;lastmod&amp;gt;$lastmod$&amp;lt;/lastmod&amp;gt;$endif$ &amp;lt;priority&amp;gt;0.8&amp;lt;/priority&amp;gt; &amp;lt;/url&amp;gt; $endfor$ &amp;lt;/urlset&amp;gt; Then, using the templates, create a rule which uses all the pages from the site as entries. Here is what I do:
create [&amp;#34;sitemap.xml&amp;#34;] $ do route idRoute compile $ do posts &amp;lt;- recentFirst =&amp;lt;&amp;lt; loadAll &amp;#34;posts/*/*&amp;#34; pages &amp;lt;- loadAll &amp;#34;pages/*&amp;#34; let allPosts = (return (pages ++ posts)) let sitemapCtx = mconcat [ listField &amp;#34;entries&amp;#34; pageCtx allPosts , constField &amp;#34;host&amp;#34; host , defaultContext ] makeItem &amp;#34;&amp;#34; &amp;gt;&amp;gt;= loadAndApplyTemplate &amp;#34;templates/sitemap.</description></item><item><title>Testing tornado websockets without third party clients</title><link>/ws-test/</link><pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate><guid>/ws-test/</guid><description>Recently, I built an encrypted chat service, which was based on tornado and ember.js. The project itself had grave security issues, so I shut it down, but while working on it I learned a few new things and testing websockets with tornado is one of them.
Most of the material out there for this suggests developing separate client based tests, which I didn&amp;rsquo;t want to do. Eventually, I figured out that tornado already provides all the utilities to do unit/integration tests for websockets.</description></item><item><title>Using pulseaudio to play system beeps</title><link>/bell/</link><pubDate>Thu, 20 Aug 2015 00:00:00 +0000</pubDate><guid>/bell/</guid><description>Recently, I built a new desktop. After receiving everything, I realized that I was missing the onboard speaker (which creates the annoying beep sound). Ideally, the computer case should have had it, but they don&amp;rsquo;t come with a buzzer anymore. My various applications rely on the system beep, hence I needed to find a software alternative. Turns out it is fairly trivial to configure it to capture alerts with pulseaudio:</description></item><item><title>The ubiquitous shell</title><link>/bash/</link><pubDate>Thu, 05 Mar 2015 00:00:00 +0000</pubDate><guid>/bash/</guid><description>Nothing makes a terminal feel more like home as one&amp;rsquo;s own shell configuration. My shell is bash, configured through a .bashrc and .profile. Bash is likely to be present in any Unix machine one uses.
Bash is also my primary IDE. This allows for keeping a relatively simple set of utilities and tools to internalize. Coupled with a reliable window manager, workflows can be quickly scripted in the head. Shell scripts are an option as well for more complex flows.</description></item><item><title>Emacs: Flymake with virtualenvs in python-mode</title><link>/emacs-flymake-with-virtualenvs-in-python-mode/</link><pubDate>Tue, 28 Jan 2014 00:00:00 +0000</pubDate><guid>/emacs-flymake-with-virtualenvs-in-python-mode/</guid><description>Lately, I have been writing some python with emacs. So, I have been trying to get the popular checkers (pylint/pyflakes) to work with flymake and virtualenvs. The issues with existing solutions to get flymake working with the checkers is that most of them assume a global version of executable (which would be fine if it weren&amp;rsquo;t for the whole python 2 and 3 incompatibility).
The python-mode in the latest emacs versions (mine is 24.</description></item><item><title>A productive workflow with vim sessions and servers</title><link>/yet-another-vim-productivity-post-server-client/</link><pubDate>Sun, 15 Apr 2012 00:00:00 +0000</pubDate><guid>/yet-another-vim-productivity-post-server-client/</guid><description>You can find lot of posts on the internet which try to tell you how to improve the ways in which Vim is used. Well, here is another one.
#Vim Server, ZSH and Tiles
A Vim instance behaves as a server in which files can be opened through remote applications. Read :help client-server of Vim to know more about this. I generally keep multiple Vim sessions running, described by task they are related to.</description></item><item><title>Configure ssh to handle proxies and tunnels seamlessly</title><link>/configure-ssh-to-handle-proxies-and-tunnels-seamlessly/</link><pubDate>Sat, 27 Aug 2011 00:00:00 +0000</pubDate><guid>/configure-ssh-to-handle-proxies-and-tunnels-seamlessly/</guid><description>Recently I opened up on the port 443 over my EC2 instance (more or less like a VPS), so that I can access it through any firewalled proxy too. Apart from getting SSH running to a machine from outside world, I did some cool configuration to have ssh deal with with various remote hosts automatically. It uses the right proxy settings according the host being accessed.
All the stuff which runs over ssh (like scp, git etc.</description></item></channel></rss>