<!DOCTYPE html>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Yeban's Weblog - Ruby Libxml Tutorial - Reader API</title>
        <meta name="author" content="Anurag Priyam" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

        <!-- Favicon -->
        <link href="/images/favicon.jpg" rel="shortcut icon">

        <!--Stylesheets-->
        <link rel="stylesheet" media="screen" type="text/css" href="/css/screen.css">
        <link rel="stylesheet" media="screen" type="text/css" href="/css/ap.css">
        <!--[if lt IE 8]><link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->
    </head>
    <body>
        <div class="container header">
    <div class="banner span-24"><a href="/">yeban's weblog</a></div>
<div class="menu span-24">
    <ul>
        <li><a href="http://github.com/yeban">Projects</a></li>
        <li><a href="http://yeban.in/about">About</a></li>
        <li><a href="http://yeban.in">Weblog</a></li>
    </ul>
</div>

</div>

<div class="container page">
    <div class="content span-24">
            <div class="post span-24">
        <div class="published">
            May 17, 2010
        </div>
        <div class="content">
            <h2 class='post-title'>Ruby Libxml Tutorial - Reader API</h2>
            <div class='post-text'>This post describes the Reader API[<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">1</a>] of <a href="http://libxml.rubyforge.org/">ruby-libxml</a>.<br /><br />Several techniques exist to parse XML documents. You can read up on them on <a href="http://en.wikipedia.org/wiki/XML#Programming_interfaces">this</a> Wikipedia article. Reader provides a <a href="http://en.wikipedia.org/wiki/StAX">StAX</a> API for parsing XML documents.<br /><br />The Reader API provides a "cursor" that moves forward through the XML document node by node and you process the data in a node while the cursor is at it. This paradigm is also called "pull parsing". You can initialize an XML document from a file, string, uri or an io object and then call <code>XML::Reader#read</code> to move through the document. The <code>read</code> method returns <code>false</code> when there is no more node to read. Optionally you can provide a hash while initializing the document to control how parsing is done. Typically, you would do something like this:<br /><br /><code>doc = XML::Reader.file("trees.xml", :options =>XML::Parser::Options::NOENT)<br />process(doc) while doc.read<br /></code><br />Possible parsing options are constants of the class <code>XML::Parser::Options</code>[<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Parser/Options.html">2</a>]. More than one options can be combined using bitwise or ( <code>|</code> ).<br /><br />After a document is parsed you should free the resources by calling <code>doc.close</code>.<br /><h4>Getting Information from the current node.</h4>While the cursor is at one of the nodes, you can query it for:<br /><ol><li>Node Type: <code> doc.node_type</code>, will return the type of the node from the following,<br /><ul><li>Start of an element : 1</li><li>Attributes : 2</li><li>Text : 3</li><li>CDATA : 4</li><li>Entity References : 5</li><li>Entity Declarations : 6</li><li>Processing Instruction : 7</li><li>Comments : 8</li><li>Document : 9</li><li>DTD/Doctype : 10</li><li>Document Fragment : 11</li><li>Notation : 12</li><li>Whitespace : 13</li><li>Significant Whitespace : 14<br /></li><li>End of an element : 15</li><li>End entity : 16</li><li>XML Declaration : 17<br /></li></ul> See [<a href="http://dotgnu.org/pnetlib-doc/System/Xml/XmlNodeType.html">3</a>] for a description of all the node types. Constants are defined for the node types under the <code>XML::Reader</code>[<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">1</a>] class.<br /></li><li>Name : <code>doc.name</code>, will return the qualified name of the node( prefix + local name )<br /><ul><li>Local Name : <code>doc.local_name</code>, will return the local name of the node( name, without the associated prefix )</li><li>Prefix : <code>doc.prefix</code>, will return the namespace prefix associated with the node</li></ul></li><li>Namespace : <code>doc.namespace_uri</code>, will return the URI of the node's namespace.<br /><ul><li>Namespace declarations are also considered node, in line with the DOM API. You can use <code>doc.namespace_declaration?</code> to find if the attribute node is a namespace declaration or not.</li><li>Given the prefix( see 2 ) you can find out the associated namespace with <code>doc.lookup_namespace("prefix")</code>; use <code>nil</code> if you want the default namespace.<br /></li></ul></li><li> Value : <code>doc.value</code>, will return the text value of the node if present else <code>nil</code>. Alternatively, you can also check if the node has a text value or not by <code>doc.has_value?</code><br /></li><li> Empty : <code>doc.empty_element?</code>, will tell you if the node is empty or not. Empty elements are those that are closed in their start tag itself. So,<br /></li><li>Depth : <code>doc.depth</code>, will return the depth of the node in the tree from the base element</li></ol><h4>Reading attributes.</h4>To find out if a node has an attribute or not, use <code>doc.has_attributes?</code>. You can find the attribute count of the node with <code>doc.attribute_count</code>. Even though attributes are also nodes, <code>doc.read</code> does not move the cursor to an attribute node.<br /><ul><li>Attributes can be accessed in a hash like manner with the <code>[]</code> method. <code>[]</code> can be called with the attribute's name or index( the first attribute is indexed 0).<br /></li><li>With the <code>doc.move_to_next_attribute</code> you can move the cursor to the next attribute. It returns 1 if the cursor moved to the next attribute and 0 if there is no attribute to move to. <code></code>While the cursor is at an attribute node you can query it like any other node( for name, value, node type, depth ) as described above. <code></code><code></code> <code></code>You must remember to move back to the element node by <code>doc.move_to_element</code>. Alternatively, you can call the <code>move_to_attribute</code> function on the cursor with a node's name as the argument to move to an attribute node. I prefer the array notation.<br /></li><li><code>read_attribute_value</code> is a related method whose use I have not understood fully. Refer the document if you will.<br /></li></ul><h4>Validation.</h4>To check if the XML document confirms to valid schema definition, call the <code>schema_validate</code> method on the reader object and pass it the location of the schema file. It returns 0 if the document validates and -1 in case of an error. Note that this function should be called just after you instantiate a <code>Reader</code> object. Trying to validate an XML document after you have started reading( called <code>read</code> on the document object ) is an error.<br /><br /><code>doc.schema_validate("schema.xsd")</code><br /><br />There are a few more API calls which you can refer here [<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">1</a>]<br /><br />Below is a "hello world" code example using the Reader API, a sample XML file and the result of parsing it. Since I have described the technicalities above, I am not going to walk you through the code.<br /><br />Code:<br /><script src="http://gist.github.com/404410.js?file=reader.rb"></script><br />Sample: it is an <a href="http://nexml.org/">NeXML</a> file.<br /><script src="http://gist.github.com/404399.js?file=sample.xml"></script><br />Output:<br /><script src="http://gist.github.com/404420.js?file=output"></script><br />XML::Reader is primarily a streaming interface, but, it also provides convenient methods to mix the DOM API( XML::Parser ). Xpath queries can then be used. Perhaps I will write about it in some future post, after I have tried it out. You can find good info at [3].<br /><br />[1] <a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">XML::Reader API Docs</a><br />[2] <a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Parser/Options.html">XML Parsing options</a><br />[2] <a href="http://dotgnu.org/pnetlib-doc/System/Xml/XmlNodeType.html">Node Types</a><br />[3] <a href="http://xmlsoft.org/xmlreader.html">Tutorial to LibXML Reader Interface( in C )</a>
 <br /></div>
            <br/>
        </div>
    </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
  /**
    * var disqus_identifier; [Optional but recommended: Define a unique identifier (e.g. post id or slug) for this thread] 
    */
  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'http://yeban-weblog.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=yeban-weblog">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


    </div>
    <div class="footer span-24">
        
    </div>
</div>

    </body>
</html>
