<!DOCTYPE html>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Yeban's Weblog - </title>
        <meta name="author" content="Anurag Priyam" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

        <!-- Favicon -->
        <link href="/images/favicon.jpg" rel="shortcut icon">

        <!--Stylesheets-->
        <link rel="stylesheet" media="screen" type="text/css" href="/css/screen.css">
        <link rel="stylesheet" media="screen" type="text/css" href="/css/ap.css">
        <!--[if lt IE 8]><link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->
    </head>
    <body>
        <div class="container header">
    <div class="banner span-24"><a href="/">yeban's weblog</a></div>
<div class="menu span-24">
    <ul>
        <li><a href="http://github.com/yeban">Projects</a></li>
        <li><a href="http://yeban.in/about">About</a></li>
        <li><a href="http://yeban.in">Weblog</a></li>
    </ul>
</div>

</div>

<div class="container page">
    <div class="content span-24">
        <div class="posts span-24">
    
    <div class="post span-24">
        <div class="meta span-3">
            <div class="date span-3">
                Jun 21, 2010
            </div>
        </div>
        <div class="content span-21 last">
            <h2 class='post-title'><a href="/finding-out-the-keycode-associated-with-a-key-.html">Finding out the keycode associated with a key.</a></h2>
            <div class="tags">
                
                    tags: linux, xev
                
            </div>
            <div class='post-text'>This one liner does the job. You need to have xev program installed:<br /><br /><code>xev | grep -A2 --line-buffered '^KeyRelease' | sed -n '/keycode /s/^.*keycode \([0-9]*\).* (.*, \(.*\)).*$/\1 \2/p'<br /></code>
 <br /></div>
            <br/>
        </div>
    </div>
    
    <div class="post span-24">
        <div class="meta span-3">
            <div class="date span-3">
                Jun 21, 2010
            </div>
        </div>
        <div class="content span-21 last">
            <h2 class='post-title'><a href="/debian-dell-touchpad.html">Debian, Dell, Touchpad</a></h2>
            <div class="tags">
                
                    tags: nil
                
            </div>
            <div class='post-text'>With the help of this[1] I was finally able to enable tapping support on my Dell Inspiron 1525 running Debian. I have posted the xorg.conf at [2]. There is another nifty hack on that page to disable touchpad. It is a very small script at [3].<br /><br />[1] <a href="http://wiki.archlinux.org/index.php/Touchpad_Synaptics">http://wiki.archlinux.org/index.php/Touchpad_Synaptics</a><br />[2] <a href="http://gist.github.com/446078">Xorg.conf</a><br />[3] <a href="http://gist.github.com/446082">toggle_touchpad.sh</a>
 <br /></div>
            <br/>
        </div>
    </div>
    
    <div class="post span-24">
        <div class="meta span-3">
            <div class="date span-3">
                May 19, 2010
            </div>
        </div>
        <div class="content span-21 last">
            <h2 class='post-title'><a href="/ruby-libxml-code-example-writing-xml-documents.html">Ruby Libxml Code Example - Writing XML Documents</a></h2>
            <div class="tags">
                
                    tags: ruby, libxml, xml, programming, phylosoc, gsoc2010
                
            </div>
            <div class='post-text'>Creating an XML document with Ruby libxml binding is very intuitive. <a href="http://libxml.rubyforge.org/rdoc/index.html">API docs</a> are good. Documentation for the XML::Document class is a good point to start. <br /><br />Consider the code below as a "Hello World" example. The code in in itself is self explanatory.<br /><br /><script src="http://gist.github.com/406307.js?file=writer.rb"></script><br /><br />The above code produces an XML file on the following lines( the only difference will be in the indentation of the attributes ):<br /><script src="http://gist.github.com/404399.js?file=sample.xml"></script>
 <br /></div>
            <br/>
        </div>
    </div>
    
    <div class="post span-24">
        <div class="meta span-3">
            <div class="date span-3">
                May 17, 2010
            </div>
        </div>
        <div class="content span-21 last">
            <h2 class='post-title'><a href="/ruby-libxml-tutorial-reader-api.html">Ruby Libxml Tutorial - Reader API</a></h2>
            <div class="tags">
                
                    tags: ruby, libxml, xml, programming, phylosoc, gsoc2010
                
            </div>
            <div class='post-text'>This post describes the Reader API[<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">1</a>] of <a href="http://libxml.rubyforge.org/">ruby-libxml</a>.<br /><br />Several techniques exist to parse XML documents. You can read up on them on <a href="http://en.wikipedia.org/wiki/XML#Programming_interfaces">this</a> Wikipedia article. Reader provides a <a href="http://en.wikipedia.org/wiki/StAX">StAX</a> API for parsing XML documents.<br /><br />The Reader API provides a "cursor" that moves forward through the XML document node by node and you process the data in a node while the cursor is at it. This paradigm is also called "pull parsing". You can initialize an XML document from a file, string, uri or an io object and then call <code>XML::Reader#read</code> to move through the document. The <code>read</code> method returns <code>false</code> when there is no more node to read. Optionally you can provide a hash while initializing the document to control how parsing is done. Typically, you would do something like this:<br /><br /><code>doc = XML::Reader.file("trees.xml", :options =>XML::Parser::Options::NOENT)<br />process(doc) while doc.read<br /></code><br />Possible parsing options are constants of the class <code>XML::Parser::Options</code>[<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Parser/Options.html">2</a>]. More than one options can be combined using bitwise or ( <code>|</code> ).<br /><br />After a document is parsed you should free the resources by calling <code>doc.close</code>.<br /><h4>Getting Information from the current node.</h4>While the cursor is at one of the nodes, you can query it for:<br /><ol><li>Node Type: <code> doc.node_type</code>, will return the type of the node from the following,<br /><ul><li>Start of an element : 1</li><li>Attributes : 2</li><li>Text : 3</li><li>CDATA : 4</li><li>Entity References : 5</li><li>Entity Declarations : 6</li><li>Processing Instruction : 7</li><li>Comments : 8</li><li>Document : 9</li><li>DTD/Doctype : 10</li><li>Document Fragment : 11</li><li>Notation : 12</li><li>Whitespace : 13</li><li>Significant Whitespace : 14<br /></li><li>End of an element : 15</li><li>End entity : 16</li><li>XML Declaration : 17<br /></li></ul> See [<a href="http://dotgnu.org/pnetlib-doc/System/Xml/XmlNodeType.html">3</a>] for a description of all the node types. Constants are defined for the node types under the <code>XML::Reader</code>[<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">1</a>] class.<br /></li><li>Name : <code>doc.name</code>, will return the qualified name of the node( prefix + local name )<br /><ul><li>Local Name : <code>doc.local_name</code>, will return the local name of the node( name, without the associated prefix )</li><li>Prefix : <code>doc.prefix</code>, will return the namespace prefix associated with the node</li></ul></li><li>Namespace : <code>doc.namespace_uri</code>, will return the URI of the node's namespace.<br /><ul><li>Namespace declarations are also considered node, in line with the DOM API. You can use <code>doc.namespace_declaration?</code> to find if the attribute node is a namespace declaration or not.</li><li>Given the prefix( see 2 ) you can find out the associated namespace with <code>doc.lookup_namespace("prefix")</code>; use <code>nil</code> if you want the default namespace.<br /></li></ul></li><li> Value : <code>doc.value</code>, will return the text value of the node if present else <code>nil</code>. Alternatively, you can also check if the node has a text value or not by <code>doc.has_value?</code><br /></li><li> Empty : <code>doc.empty_element?</code>, will tell you if the node is empty or not. Empty elements are those that are closed in their start tag itself. So,<br /></li><li>Depth : <code>doc.depth</code>, will return the depth of the node in the tree from the base element</li></ol><h4>Reading attributes.</h4>To find out if a node has an attribute or not, use <code>doc.has_attributes?</code>. You can find the attribute count of the node with <code>doc.attribute_count</code>. Even though attributes are also nodes, <code>doc.read</code> does not move the cursor to an attribute node.<br /><ul><li>Attributes can be accessed in a hash like manner with the <code>[]</code> method. <code>[]</code> can be called with the attribute's name or index( the first attribute is indexed 0).<br /></li><li>With the <code>doc.move_to_next_attribute</code> you can move the cursor to the next attribute. It returns 1 if the cursor moved to the next attribute and 0 if there is no attribute to move to. <code></code>While the cursor is at an attribute node you can query it like any other node( for name, value, node type, depth ) as described above. <code></code><code></code> <code></code>You must remember to move back to the element node by <code>doc.move_to_element</code>. Alternatively, you can call the <code>move_to_attribute</code> function on the cursor with a node's name as the argument to move to an attribute node. I prefer the array notation.<br /></li><li><code>read_attribute_value</code> is a related method whose use I have not understood fully. Refer the document if you will.<br /></li></ul><h4>Validation.</h4>To check if the XML document confirms to valid schema definition, call the <code>schema_validate</code> method on the reader object and pass it the location of the schema file. It returns 0 if the document validates and -1 in case of an error. Note that this function should be called just after you instantiate a <code>Reader</code> object. Trying to validate an XML document after you have started reading( called <code>read</code> on the document object ) is an error.<br /><br /><code>doc.schema_validate("schema.xsd")</code><br /><br />There are a few more API calls which you can refer here [<a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">1</a>]<br /><br />Below is a "hello world" code example using the Reader API, a sample XML file and the result of parsing it. Since I have described the technicalities above, I am not going to walk you through the code.<br /><br />Code:<br /><script src="http://gist.github.com/404410.js?file=reader.rb"></script><br />Sample: it is an <a href="http://nexml.org/">NeXML</a> file.<br /><script src="http://gist.github.com/404399.js?file=sample.xml"></script><br />Output:<br /><script src="http://gist.github.com/404420.js?file=output"></script><br />XML::Reader is primarily a streaming interface, but, it also provides convenient methods to mix the DOM API( XML::Parser ). Xpath queries can then be used. Perhaps I will write about it in some future post, after I have tried it out. You can find good info at [3].<br /><br />[1] <a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Reader.html">XML::Reader API Docs</a><br />[2] <a href="http://libxml.rubyforge.org/rdoc/classes/LibXML/XML/Parser/Options.html">XML Parsing options</a><br />[2] <a href="http://dotgnu.org/pnetlib-doc/System/Xml/XmlNodeType.html">Node Types</a><br />[3] <a href="http://xmlsoft.org/xmlreader.html">Tutorial to LibXML Reader Interface( in C )</a>
 <br /></div>
            <br/>
        </div>
    </div>
    
    <div class="post span-24">
        <div class="meta span-3">
            <div class="date span-3">
                May 16, 2010
            </div>
        </div>
        <div class="content span-21 last">
            <h2 class='post-title'><a href="/zenburn-vim-color-scheme.html">Zenburn - Vim Color Scheme</a></h2>
            <div class="tags">
                
                    tags: vim, linux, programming
                
            </div>
            <div class='post-text'>I used to use ir_black color scheme for Vim before I discovered <a href="http://www.vim.org/scripts/script.php?script_id=415">zenburn</a>. A low contrast color scheme, Zenburn is perfect for programming. Zenburn is easy on eyes. Zenburn is awesome! Here is a screen shot showing some C code in my Vim.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_uEnvaxJViA4/S_AeoUR3zhI/AAAAAAAAAhE/JdwOKZ4g7Ns/s1600/priyam-zenburn.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 125px;" src="http://3.bp.blogspot.com/_uEnvaxJViA4/S_AeoUR3zhI/AAAAAAAAAhE/JdwOKZ4g7Ns/s200/priyam-zenburn.png" alt="" id="BLOGGER_PHOTO_ID_5471907225242422802" border="0" /></a>
 <br /></div>
            <br/>
        </div>
    </div>
    
</div>

<div class="paginator">
    <a href="/page/">Previous</a>
    <a href="/page2/">Next</a>
</div>

    </div>
    <div class="footer span-24">
        
    </div>
</div>

    </body>
</html>
